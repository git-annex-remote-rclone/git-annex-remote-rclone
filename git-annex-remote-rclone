#!/usr/bin/env python3

# git-annex-remote-rclone - wrapper to enable use of rclone-supported cloud providers as git-annex special remotes.
#
# Install in PATH as git-annex-remote-rclone
#
# Copyright (C) 2016-2022  Daniel Dent
#               2022       git-annex-remote-rclone contributors
#
# This program is free software: you can redistribute it and/or modify it under the terms of version 3 of the GNU
# General Public License as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# Based on work originally copyright 2013 Joey Hess which was licenced under the GNU GPL version 3 or higher.

import os
import re
import sys
import shutil
import tempfile
import subprocess

def say(cmd, *messages):
    print(cmd, *messages)
    sys.stdout.flush()

def ask(cmd, *query):
    say(cmd, *query)
    resp_key, _, resp_value = sys.stdin.readline().partition(" ")
    if resp_key == "VALUE":
        return resp_value.rstrip()
    if resp_key == "CREDS":
        return resp_value.split(" ", 1).rstrip()

def rclone(*args):
    proc = subprocess.Popen(("rclone",) + args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    output = proc.stdout.read()
    return proc.wait(), output.decode("utf8")

def get_config(key):
    return ask("GETCONFIG", key)

def set_config(key, value):
    say("SETCONFIG", key, value)

def debug(*messages):
    say("DEBUG", " ".join(map(str, messages)))


class Remote(object):

    def initremote(self):
        try:
            self.remote_prefix = get_config("prefix")
            if not self.remote_prefix:
                self.remote_prefix = "git-annex"
            if self.remote_prefix == "/":
                raise RuntimeError("storing objects directly in the root (/) is not supported")
            set_config("prefix", self.remote_prefix)

            self.remote_target = get_config("target")
            set_config("target", self.remote_target)

            self.rclone_layout = get_config("rclone_layout") or "lower"
            self._validate_layout()
            set_config("rclone_layout", self.rclone_layout)

            if not self.remote_target:
                raise RuntimeError("rclone remote target must be specified (use target=parameter)")

            if rclone("mkdir", f"{self.remote_target}:{self.remote_prefix}")[0]:
                raise RuntimeError("Failed to create directory on remote. Ensure that 'rclone config' has been run.")

        except RuntimeError as err:
            say("INITREMOTE-FAILURE", err)
        else:
            say("INITREMOTE-SUCCESS")

    def prepare(self):
        self.remote_prefix = get_config("prefix")
        self.remote_target = get_config("target")
        self.rclone_layout = get_config("rclone_layout") or "lower"
        try:
            self._validate_layout()
        except RuntimeError as err:
            say("PREPARE-FAILURE", err)
        else:
            say("PREPARE-SUCCESS")

    def transfer(self, op, key, *file):
        file = " ".join(file)
        location = self._calculate_location(key)

        if op == "STORE":
            # Store the file to a location
            # based on the key.
            # XXX when at all possible, send PROGRESS
            if not os.path.exists(file):
                say("TRANSFER-FAILURE", "STORE", key, f"asked to store non-existent file {file}")
            else:
                if not rclone("copy", file, location)[0]:
                    say("TRANSFER-SUCCESS", "STORE", key)
                else:
                    say("TRANSFER-FAILURE", "STORE", key)

        elif op == "RETRIEVE":
            # Retrieve from a location based on
            # the key, outputting to the file.
            # XXX when easy to do, send PROGRESS
            try:
                with tempfile.TemporaryDirectory(prefix="rclone-annex-tmp.") as tmp:
                    if rclone("copy", location + key, tmp)[0]:
                        raise RuntimeError("Failed to copy")
                    shutil.move(os.path.join(tmp, key), file)
            except (OSError, IOError, RuntimeError):
                say("TRANSFER-FAILURE", "RETRIEVE", key)
            else:
                say("TRANSFER-SUCCESS", "RETRIEVE", key)
        else:
            raise RuntimeError(f"Unknown operation {op}")

    def checkpresent(self, key):
        location = self._calculate_location(key)
        code, output = rclone("size", "--json", location + key)
        match_ = re.search(r'"count":\s*(\d+)', output)
        count = match_ and int(match_.group(1))

        if not code and count is not None and count >= 1:
            # Any nonzero object count means present.
            # Some rclone backends support multiple
            # files under one name.
            say("CHECKPRESENT-SUCCESS", key)
        elif not code and count is not None and count == 0:
            # A 0 object count means an empty directory.
            say("CHECKPRESENT-FAILURE", key)
        elif code in (3, 4):
            # file or directory doesn't exist
            # see https://rclone.org/docs/#exit-code
            say("CHECKPRESENT-FAILURE", key)
        else:
            say("CHECKPRESENT-UNKNOWN", key, "remote currently unavailable or git-annex-remote-rclone failed to parse rclone output")

    def remove(self, key):
        # Note that it's not a failure to remove a
        # key that is not present.
        location = self._calculate_location(key)
        code, output = rclone("delete", "--retries", "1", location + key)
        if not code or " directory not found" in output:
            say("REMOVE-SUCCESS", key)
        else:
            say("REMOVE-FAILURE", key)

    def _validate_layout(self):
        if self.rclone_layout not in ("lower", "directory", "nodir", "mixed", "frankencase"):
            raise RuntimeError("rclone_layout setting not recognized")

    def _calculate_location(self, key):
        # Sets LOC to the location to use to store a key.
        if self.rclone_layout == "lower":
            dir_hash = ask("DIRHASH-LOWER", key)
            return f"{self.remote_target}:{self.remote_prefix}/{dir_hash}"
        if self.rclone_layout == "directory":
            dir_hash = ask("DIRHASH-LOWER", key)
            return f"{self.remote_target}:{self.remote_prefix}/{dir_hash}{key}/"
        if self.rclone_layout == "nodir":
            return f"{self.remote_target}:{self.remote_prefix}/"
        if self.rclone_layout == "mixed":
            dir_hash = ask("DIRHASH", key)
            return f"{self.remote_target}:{self.remote_prefix}/{dir_hash}"
        if self.rclone_layout == "frankencase":
            dir_hash = ask("DIRHASH", key).lower()
            return f"{self.remote_target}:{self.remote_prefix}/{dir_hash}"
        raise RuntimeError(f"Unknown layout {self.rclone_layout}")


def main():
    say("VERSION", "1")
    remote = Remote()
    for line in iter(sys.stdin.readline, ""):
        parts = line.rstrip().split()
        func = getattr(remote, parts[0].lower(), None) or (lambda *_: say("UNSUPPORTED-REQUEST"))
        func(*parts[1:])


if __name__ == "__main__":
    main()
